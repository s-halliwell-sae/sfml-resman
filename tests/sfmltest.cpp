#include <ResourceManager/SFML/ManagedTexture.hpp>
#include <ResourceManager/ResourceManager.hpp>
#include <ResourceManager/Logger.hpp>
#include <SFML/Graphics.hpp>
#include <thread>
#include <chrono>

void run()
{
    sf::RenderWindow window(sf::VideoMode(800, 600), "Managed SFML Test");

    // Init the resource manager and set it to try to use error resources
    // This test doesn't have any yet so should the test resources go
    //  missing, it will crash when their use is attempted
    rm::ResourceManager::init(false);
    rm::Logger::setFileLocation("log.txt");

    // Allows the rm::ResourceManager to create new rm::ManagedTextures
    rm::ResourceManager::addResourceType<rm::ManagedTexture>();

    // Queue a resource pack for loading
    rm::ResourceManager::loadPack("resourcepacks/sfmltestpack.lua", rm::LoadMode::Queue);

    // Fetch the resource stubs, which will not be loaded yet
    auto mt = rm::ResourceManager::getResource<rm::ManagedTexture>("textureTest");
    auto mt2 = rm::ResourceManager::getResource<rm::ManagedTexture>("textureTest2");

    // Create two sprites and give them the empty textures generated by loadPack
    sf::Sprite sprite, sprite2;
    sprite.setTexture(*mt->getTexture());
    sprite2.setTexture(*mt2->getTexture());

    // Just so the two sprites don't overlap
    sprite2.setPosition(sf::Vector2f(200, 50));

    rm::ResourceManager::setLoadCompleteCallback([&](){
        // Once the texture has been loaded, sprites using it must update
        //  the sprites using it must update their texture rects
        auto size = mt2->getTexture()->getSize();
        auto rect = sf::IntRect(sf::Vector2i(0,0), sf::Vector2i(size));

        // This is kind of hacky but kind of ok
        // The reason I'm giving both sprites the same
        //  texture rect is because I know both
        //  textures are the same size
        sprite.setTextureRect(rect);
        sprite2.setTextureRect(rect);

        rm::Logger::logMessage("load complete");
    });

    while(window.isOpen())
    {
        // Check events
        sf::Event event;
        while (window.pollEvent(event))
        {
            if (event.type == sf::Event::Closed)
                window.close();
        }

        // Draw all the things
        window.clear();
        window.draw(sprite);
        window.draw(sprite2);
        window.display();

        // Sleep for one second to demonstrate the delayed loading
        //  of resources
        std::this_thread::sleep_for(std::chrono::milliseconds(500));
        rm::ResourceManager::update();
    }
}

int main()
{
    try
    {
        run();
    }
    catch(const char* e)
    {
        rm::Logger::logMessage(e);
    }
    rm::ResourceManager::cleanupUnused();

    return 0;
}